[[sec_hfi_base]]

== Base HFI Extension

[[sub_sec_sbx_setup]]
=== Sandbox Setup

The sandboxing runtime can query if the processor supports HFI by checking the supported extension string from the device tree or the ACPI RISC-V Hart Capabilities Table as is the common practice cite:[riscv-ext-cpuid]. Specifically, the string will list "hfi-_version_" if HFI is supported. The HFI version described in this spec is "1".

If HFI is supported, HFI mode is enabled with the `hfienter` instruction, and disabled with the `hfiexit` instruction. The `hfienter` instruction has two variants---the first variant takes a single register operand which specifies the sandbox configuration options as a bit vector called `hfioptions_t`, that has the following fields:

* _lock_regions_: _reg_u1_---Regions configurations are normally specified prior to `hfienter`, using instructions such `hfisetregionsize` (See <<sub_sec_regions,Chapter 2.3>>). If _lock_regions_ is set to _false (0)_, region manipulation instructions can also be called while in HFI mode (i.e., the region configuration can be modified in the sandbox). If _true (1)_, these instructions cannot be called while in HFI mode.

* _redirect_system_calls_: _reg_u1_---HFI sandboxes can interpose on system calls made by sandboxed code. If _redirect_system_calls_ is set to _false (0)_, system calls are unaffected by HFI. If _true (1)_, HFI will redirect system calls (`ecall`) instructions to the HFI exit handler (which can be set with the `hfisetexithandler` instruction discussed in <<sub_sec_exit_handler,Chapter 2.2>>).

* _redirect_exits_: _reg_u1_---HFI sandboxes can interpose on invocations of `hfiexit` so the application can take control once the sandbox code completes. If _redirect_exits_ is set to _false (0)_, `hfiexit` disables HFI and execution simply falls through to the next instruction. If _true (1)_, `hfiexit` disables HFI and redirects control flow to the exit_handler (which can be set with the `hfisetexithandler` instruction discussed in <<sub_sec_exit_handler,Chapter 2.2>>).

* _serialize_enter_exits_: _reg_u1_---HFI sandboxes can add fences sandbox entries and exit (through the `hfienter` and `hfiexit` instructions), a required step for Spectre protections. If _serialize_enter_exits_ is _false (0)_, these instructions do not introduce any serialization or fencing. If _true (1)_, these instructions act as a fence for all memory operations that are run prior to these instructions.

The second variant of `hfienter` operates like `hfienter` variant 1 plus a jump instruction; it takes the `hfioptions_t` as the first operand and takes the target of the jump in a register as the second operand.

// "CSRs" here
// hfi_usermode_enabled (changed to hfi_status_reg)
// hfi_access_violation (should change to hfi_fault_status_reg)

**Behavior**
// [NOTE]
// --
// some of the CSRs here does not cohere with later in the doc. also, need to clarify that this isn't even CSR
// --
The `hfienter` instruction interacts with multiple internal registers. It sets the field `hfiusermodeenabled` in an internal register `hfistatusreg` to 1 on execution, and clears the `hfifaultoccurred` field in another internal register `hfifaultstatusreg` indicating that there has not been a violation of HFI's region rules since the last invocation of `hfienter`. The second variant of `hfienter` additionally sets the PC to the target specified in the second operand after its execution.
The `hfiexit` instruction interacts with all three fields from `hfistatusreg`. It sets its `hfiusermodeenabled` field to 0 on execution, write the value of the program counter of the `hfiexit` instruction to its `hfiexitpc` field, and set its `hfiexitreason` field to 1, indicating the sandbox exit was due to and `hfiexit` instruction.
`hfienter` and `hfiexit` must always act as fence for other HFI instructions, i.e., they only execute after all in-flight HFI instructions have completed.

**Faults**
The `hfienter` instruction will trap if the CPU is already in HFI mode. The `hfiexit` instruction will trap if the CPU is not in HFI mode.

**Design Rationale**
Most of the options in `hfioptions_t` are present to support different use cases. When executing unmodified native code, the sandboxed code is totally untrusted, thus regions are locked, system calls are redirected, etc. However, when sandboxing code from existing SFI systems such as WebAssembly, it is more efficient/not necessary for HFI to do some checks, since these systems already handle some safety checks in their compiler/runtime. For example, these systems may not want to redirect system calls.
Similarly, the choice of whether or not to serialize `hfiexit` and `hfienter` will depend on the threat model that a particular application is trying to enforce (i.e. if they want greater Spectre safety), we leave it to the user to choose whether they wish to opt into this added overhead. Finally, `hfienter` is offered in two variants as some sandboxing runtimes may want the option to jump directly to executing sandboxed code after sandboxing is enabled via `hfienter`, while other runtimes may want the instruction to fall through to avoid any costs due to extra control flow. The former behavior can be difficult to accomplish with the single operand variant of `hfienter` as it requires the instruction following `hfienter` to be part of the sandbox's code---which may not always be possible. The latter behavior's performance is difficult to achieve with an instruction that includes control flow.

[[sub_sec_exit_handler]]
=== Configuring the Exit handler

HFI supports interposition via. redirection on all paths out of the sandbox including sandbox exits (via. `hfiexit`) and system calls (and by extension signals). As noted, which instructions (system calls and/or `hfiexit`) are redirected is configured through `hfioptions_t`, that is passed as an operand to `hfienter`.

To handle this redirection, an exit handler is setup with the `hfisetexithandler` instruction. This instruction should be invoked prior to `hfiexit`. `hfisetexithandler` takes one operand, a 64-bit register, that holds the address of the exit handler. The current exit handler can be retrieved via the `hfigetexithandler` instruction.

**Behavior**
The `hfisetexithandler` instruction sets the `hfiexithandlerreg` internal register to the address specified in its operand.

* If `hfiexit` is configured to invoke the exit handler, the `hfiexit` instruction, when executed by sandbox code, will jump to the exit handler _after_ execution (during which `hfiexitreason` in `hfistatusreg` is set to 1 indicating the exit was due to the `hfiexit` instruction).

* If system calls are configured to invoke the exit handler, the system call instruction, when executed by sandbox code, will jump to the exit handler _before_ execution, set the `hfiexitreason` field to 2 indicating the exit was due to a system call, and disable sandboxing by setting the `hfiusermodeenabled` field to 0.

**Faults**
The `hfisetexithandler` instruction will trap if the CPU is already in HFI mode. If the exit handler is set to a location without code permissions, the behavior of the CPU would be identical to a normal jump to an address without code permissions.

**Design Rationale**
Sandboxed code will invoke `hfiexit` to exit the sandbox. We must ensure that the sandboxed code always returns control to the sandboxing runtime after exits, which means, invocation of `hfiexit` should return control to trusted code. Thus, we have added support for redirecting all invocations of `hfiexit`.

Sandboxed code can also invoke system calls; since HFI's restrictions don't apply to kernel code, system calls could be used to bypass isolation enforced by the hardware cite:[pku-pitfalls]. Thus, trusted code needs the ability to interpose on system calls, so that it can restrict the invocation of unsafe system calls by sandboxed code. Such interposition on system calls could be done using assembly rewriting or using kernel features such as EBPF, however, this is slow and cumbersome. To allow efficient interposition of system calls, HFI provides hardware support to redirect system calls. When enabled, system calls simply act like a jump instruction to the exit handler.

[[sub_sec_regions]]
=== Regions

Regions offer a limited version of the functionality found in traditional segmented memory systems, which control access to contiguous ranges of memory using `<base, bound, permission>` tuples.

By default, a processor in HFI mode has no access to memory, i.e. it cannot read data or run code. To enable sandboxed code to run, a sandbox runtime must explicitly configure regions prior executing `hfienter`. In the next sections, we provide a brief overview of HFI regions, and then specify how to configure these them.

[[subsec_region_types]]
==== Regions Types

HFI base extension provides regions that _implicitly_ apply bound checks to every memory access when the sandbox is enabled. These regions are thus also called "implicit regions". This is essential for isolating memory accesses and control flow of unmodified native code. HFI discriminates such regions into code and data ones, to keep the control and data pipelines simpler and more efficient. Data regions can grant read and write access and only apply to loads and stores, while code regions apply only to instruction fetches, and can only grant execute permissions.

With every memory access under bound checks, data regions grant access on a first-match basis. For example, if sandboxed code executes an "`lw rd, rs(offset)`" instruction, HFI will check if the address in `rs + offset` is in range for _any_ of the existing regions in parallel. For the first matching region, it will check the permissions to see if reads are allowed -- if so, it will proceed. If the permission check fails, or if there is no match, HFI will trap. Code regions apply similar checks to code.

Specifically, regions perform bound checks based on _prefix matching_. Each region specifies a _base_prefix_ (the `base` component in the region's tuple) and an _lsb_mask_ (the `bound` component in the region's tuple). To check if an address is in bounds, HFI uses the _lsb_mask_ to remove the least significant bits of the address, and compares the remaining prefix to _base_prefix_.
Thus, regions must be power of two sized and aligned -- thus, they trade granularity for efficient checking -- in particular, checks can be implemented with simple masking operations. 

// HFI provides six implicit regions per-sandbox, four data regions (e.g., for the heap),
// and two code regions (e.g., for the application and shared library
// code) -- The region count was based on experience sandboxing code in
// production settings.



**Notes on size and alignment**
Unaligned memory operations that are split by the micro-architecture into independent operations will be checked independently by HFI. If one split faults, the original fused instruction will fault, as will the split instruction that violates HFI bounds. However, the split operation that is within bounds may be allowed to have visible _micro-architectural_ side effects within the sandbox.

Regions also have minimum sizes. The smallest implicit region is 64 bytes. The behavior of regions that do not meet these minimums is undefined.

[[subsec_manip_regions]]
==== Manipulating Regions

Region state, which is stored in internal registers, can only be read or modified by HFI instructions. The instructions broadly operate on regions by a region number (`region_number_t`) -- a unique number/index assigned to each HFI region on the CPU.

**Region number assignments**
The version of HFI in this spec (hfi1) up to this chapter defines two regions: one implicit data region of `region_number_t` of 1, and one implicit data region of `region_number_t` of 2. Future versions may define multiple regions of each type (<<sub_subsec_standard_profile,Chapter 3.5>>), and each region will be assigned a unique `region_number_t`.

We now introduce the instructions that can configure these regions:

**Setting Region base and size**
The following instructions are used to specify the range of memory a region applies to. To configure a specific region's base and size, a sandboxing runtime must first select the target region. This is accomplished by direct instructions that write to a dedicated register indicating current region being configured. Once a region is selected, its base address and mask (bound) can be configured using separate instructions that target dedicated registers. This approach breaks down the operation to fit standard RISC-V instruction formats, avoiding having multiple destination registers.

`hfiselectregion`(_region_number_t_)

`hfisetregionbase`(_reg_u64 base_)

`hfigetregionbase`() -> _reg_u64 base_

`hfisetregionbound`(_reg_u64 mask_or_bound_)

`hfigetregionbound`() -> _reg_u64 mask_or_bound_

**Behaviour**
The region to configure is set with `hfiselectregion`, and then its sizes and locations are set using `hfisetregionbase` and `hfisetregionbound`. Regions are typically setup prior to entering the sandbox (with `hfienter`). If this instruction runs in a sandbox, i.e., `hfiusermodeenabled` is 1 -- which is allowed when `lock_regions` is 0 -- it must act as a memory fence. All prior memory instructions must complete before executing this instruction and subsequent memory operations should be issued only after the update.

`hfiselectregion` has `region_number_t` as its operand register, and works closely with the other four instructions. While `hfisetregionbase` has the base of the region as its operand, `hfisetregionbound`'s operand depends on the type of region. The third operand should contain the mask for the region. The value of the base and bound/mask should additionally conform to the per-region size and alignment requirements in <<subsec_region_types, Chapter 2.3.1>>. However, the instruction does not check whether operands meet this criteria. If the operands don't meet the criteria, the resulting behavior is undefined.

// Concretely, explicit data regions should have {base_address, bound} that conform
// to the following restrictions: for large regions base, bound are multiples of
// 64k; for small regions, regions can be up to 4GB in size, sizes are byte
// granular and a region cannot span a 4GB boundary.
// [TODO]
// --
// implicit regions
// --

`hfigetregionbound`, `hfigetregionbase`, and `hfigetregionbound` return region size information based on the previously fed `region_number_t`. 

**Faults**
These instructions fault if the region number specified does not exist (i.e., it is greater than the total number of regions). For efficiency, these instructions should not check whether region locations or sizes are invalid (e.g., the program has specifies an implicit region base that is not aligned to its size); rather the hardware will continue to operate using the provided base and size, although this behavior is to be considered undefined.

**Design Rationale**
When `hfisetregionsize` is run prior to `hfienter`, it doesn't need to act as a fence as `hfienter` can fulfill this purpose. However, when used inside the sandbox, `hfisetregionsize` must act as a fence, as otherwise inflight memory operations could potentially access memory outside the sandbox when they were issued if a region resized.

**Setting Permissions, Enabling/Disabling Regions**
The following instructions are used to configure permissions on regions, as well as to enable and disable regions.

`hfisetregionpermission`(_permission_set_t_, _permission_t_)

`hfigetregionpermission`(_permission_set_t_) -> _permission_t_

**Behaviour**
Region permissions are set using the `hfisetregionpermission` instruction. This instruction sets the permissions of all regions using a single bit vector. The instruction takes `permission_set_t` as the first argument. This is a 32-bit register which must have the value 0; other values are reserved for future use. The second operand to this instruction is a permission bit-vector `permission_t` encoded as follows:

* Bits 0 to 2 are permissions for implicit data region 1. Bit 0 indicates if the region is enabled (i.e., should be enforced by the sandbox). Bit 1 and 2 indicates whether the region has read and write permissions respectively.

* Bits 3 to 4 are permissions for implicit data region 1. Bit 3 indicates if the region is enabled. Bit 4 indicates whether the region has execute permissions.

**Faults**
This instruction will fault if the `permission_set_t` is not set to 0, or if `hfiusermodeenabled` and `lock_regions` is set to 1 (when hfi mode is on with region configurations locked). Any unused bits of `permission_t` are ignored; thus setting an unused bit will not fault.

**Design Rationale**
An alternate design for this instruction would be to split up `hfisetregionpermission` to operate per-region (by changing the instruction to take `region_number_t` to operate on as the first parameter). However, this would lead to additional overheads in practice. This is because this instruction is primarily used when switching between active sandboxes. In this case, the permissions of all regions would likely need to be adjusting. If `hfisetregionpermission` operated per region, then three calls to this instruction would be needed to adjust the permissions of the three regions. In contrast, our design allows this to occur in a single instruction. Additionally, the `permission_set_t` parameter further future-proofs this design by allowing us to modify the format of this instruction for future versions of HFI, without breaking backward compatibility.

**Clearing Regions**
To clear region state rapidly e.g. on context switches, HFI offers `hfiresetregions`.

**Behaviour**
This instruction sets the base and bound/mask of all regions to zero (equivalent to calling `hfisetregionsize` with arguments of 0 on all regions), disables all regions and sets their permissions to zero (equivalent to calling `hfisetregionpermission` with a permission vector of 0).

**Faults**
This instruction faults if `hfiusermodeenabled` and `lock_regions` is set to 1 (when hfi mode is on with region configurations locked).

**Design Rationale**
While this instruction can effectively be achieved using combinations of other instructions, unifying this "reset" operation into a single instruction allows optimizing a number of paths. For example, when an application needs to switch between multiple sandboxes, software has to clear the state of the first sandbox before applying the state of the second sandbox. This allows optimizing the first step sequence. This operation is also useful when the OS kernel is switching between two scheduled processes both of which may use HFI. The OS kernel is responsible for saving and restoring each processes' HFI state, and thus can also use this instruction.

==== Implementation Considerations

**Implementation Semantics and Spectre**  To ensure Spectre safety, the following guidance is offered for implementers.

_For code regions:_ To ensure security, prefix-checking should be carried out in parallel with the decode stage. If the check finds a matching region with execute permissions, it succeeds, and decode carries on normally. If the check fails, it prevents the decoded micro-ops from entering the pipeline, and instead translates all instructions into a faulting NOP micro-op. This ensures that instructions that are out-of-bounds are not executed during committed execution, and are also not executed speculatively.

_For data regions:_ Bounds checking, DTLB lookup, and cache index lookups should happen in parallel. One concern here is that, cache state could be modified as a result of secret (out-of-bounds) data. To prevent this sort of side-channel attack all bounds must checks occur _before_ the processor resolves the physical address of a memory access. This is secure because the processor can update cache metadata like the LRU bits (for hits) or fetch new data blocks (for misses) only after resolving the physical address. HFI can therefore strictly prevent any metadata updates if there has been a fault.

Note that out-of-bounds address can affect metadata of the DTLB or i-cache---e.g., LRU bits. However, the invariant we guarantee---no secret (data stored outside the boundaries of the region) ever affects architectural state---is still not violated, since we do not allow the _result_ of an out-of-bounds memory operation to propagate into any of these structure.

To summarize, HFI's data pipeline is Spectre safe, since the data cache is not updated prior to bounds checks being completed; HFI's control pipeline is safe as bounds checks finish prior to instruction decode which is before the execution of instructions. This approach also helps to guarantee that any code executed as the result of PHT, BTB, and RSB (speculative) predictions are checked prior to execution.

[[sub_sec_regs]]
=== New Internal Registers

HFI stores state for the current sandbox in internal registers including: (1) the sandbox status (2) the exit handler (3) region configuration (4) the cause and status of HFI induced faults (traps).

==== Sandbox Status Register

**Fields**
The sandbox status, stored in the `hfistatusreg` internal register, is read-only to userspace software, but writable by kernel code. The contents of the `hfistatusreg` register are as follows:

* _hfi_usermode_enabled_ (1-bit): is updated automatically during `hfienter` (set to true), `hfiexit` (set to false), and when the exit handler is called (set to false).
* _hfi_exit_reason_ (2-bit): indicates the reason for the last sandbox exit. Exit due to `hfiexit` would leave this set to 1. Exit due to a system call with leave this set to 2.
* _hfi_exit_pc_ (60-bit): indicates the PC of the instruction causing the last exit. The first 2-bits and the last 2-bits of the PC are dropped and are assumed to be zero. Thus 60-bits of the PC are stored.

**Serialization Caveat**
The `hfistatusreg` register should support updates via register renaming to support the performance expectations of hardware sandboxing. These values are expected to change frequently (once in few thousand instructions), and serializing this register updates with techniques like score-boarding will hinder practical adoption.

==== Exit Handler Registers

**Fields**
The address of the sandbox exit handler is stored in the `hfiexithandlerreg` internal register. When a sandboxed hart traps or executes an `hfiexit` instruction, the Program Counter (PC) is set to the value stored in this register. This register is written to using the `hfisetexithandler` instruction and read using the `hfigetexithandler` instruction. The contents of the `hfiexithandlerreg` register are as follows:

* _Exit Handler Address_ (60-bit): indicates the address of the exit handler set for current sandbox. The first 2 bits and last 2 bits of this address are dropped and assumed to be zero.

**Serialization Caveat**
The exit handler of the sandbox is stored in the `hfiexithandlerreg` internal register and can be set or read via the `hfisetexithandler` and `hfigetexithandler` instructions. Since the register is not expected to be frequently updated, it's updates may be scoreboarded if needed.

==== Region Registers

**Fields**
There are three sets of internal registers dedicated to region configurations required by hfi: bounds registers, permissions registers, and selector registers. Different version of HFI may require different numbers of these registers, as discussed in <<sub_subsec_standard_profile,Chapter 3.5>>. Bounds registers specify the bounds and sizes of a region. Each implicit region (data or code) has a 64-bit prefix register and a 64-bit mask register. Permissions registers specify whether a region can be read, written, or executed. Each data region has a 1-bit write field and a 1-bit read field, while each code region has a 1-bit execute field. On top of these registers is the selector register, which contains the region number of the region currently being configured. Its only field is a 32-bit `region_number_t`.

**Serialization Caveat**
The region registers cannot be directly named, and must instead be modified or accessed through HFI instructions (e.g. `hfigetregionsize`). Since these registers should updated whenever a sandbox switch occurs, updates to these registers should ideally be supported through register renaming; however, implementations may choose to use the slightly less expensive scheme.
In particular, implementations can configure the regions outside the sandbox without serializing, and defer fencing to when an `hfienter` instruction executes. This way, updates to these registers do not fence, and the `hfienter` instruction waits for all pending region register updates to complete. When a sandbox is enabled (`hfiusermodeenabled` set to 1), region register updates are not permitted if `lock_regions` option is set to 0. In the case that the region is not locked, however, all updates to the region register within the sandbox must serialize.

[[sec_hfi_faults]]
==== Fault Registers

**Fields**
The result of an HFI fault due to an HFI policy violation is stored in the `hfifaultstatusreg` register. This register stores the precise cause of an HFI induced fault (trap). Since the register is not expected to be frequently updated, itâ€™s updates may be scoreboarded if needed. Information in `hfifaultstatusreg` is readable in user space so the runtime can respond appropriately, and read-write in the kernel so that this state can be saved/restored as part of the process context, as multiple processes may be using HFI, and fault delivery is asynchronous. This register has four fields:

* _hfi_fault_occurred_ (1-bit): is a bit that indicates that an hfi fault has occurred.
* _hfi_fault_region_ (8-bit): indicates which region the fault occured in. If the fault was caused by an implicit region i.e. insufficient permission to access a matched region, it will contain the number of the region. If the fault was cause because no implicit region matched an operation, it will contain 0.
* _hfi_fault_op_ (2-bit): indicates the operation that faulted, this will be a `LOAD_FAULT` or `STORE_FAULT` for a failed load or store, `FETCH_FAULT` for a failed instruction fetch, or `AMO_FAULT` for a fault that occurred during an atomic memory operation.
* _hfi_fault_type_ (1-bit): indicates the type of fault. If `OUT_OF_BOUNDS`, it indicates that no implicit region matched the operation (in this case `hfi_fault_region` will be equal to zero). If `INSUFFICIENT_PERMISSIONS`, whichever implicit region matched the operation did not have sufficient permissions.

**Design Rationale**
The `hfienter` and `hfiexit` instructions modify the various bits of the `hfistatusreg` register. The updates to this register must be fast to allow rapid entries and exits to HFI mode; thus this must be supported by register renaming. Region registers are updated frequently as well when switching between different sandboxes. While this would ideally support register renaming for efficient register updates, an alternate scheme that ensures a single serialization (on entry into the sandbox) for a batch of region updates prior to entry, would provide adequate performance. Finally, updates to the region configuration within the sandbox should serialize, as an updates during speculative execution may allow Spectre-style attacks to break out of the sandbox.


[[sub_sec_using_hfi]]
=== Using HFI

Here we explore how HFI's features are used to create sandboxing runtimes in userspace, and the HFI support needed from the operating systems.

==== Sandboxing in Userspace

Suppose we have a sandbox runtime (e.g. part of an application implementing a Wasm FaaS server, or a library sandboxing framework cite:[rlbox]), that is ready to create new sandbox.
We assume that the runtime has reserved some memory for the sandbox (i.e., the sandbox memory), has placed the input for the sandboxed code in a memory buffer, and the sandboxed code itself is separated from other code and mapped in an isolated contiguous portion of the address space. Our runtime can now take the following steps:

**Setting up regions**
To start, our runtime sets up access to the code, heap, and input memory so our application has everything it needs once the sandbox starts, it does this using the `hfisetregionsize`, `hfisetregionpermission` instructions to setup and enable regions that grant access to the allocated heap and inputs, and the application code. If no code regions are mapped, HFI will immediately trap after `hfi_enter` is called, as the processor will not be able to fetch instructions.

What type of regions the runtime will use, as as how the sandbox is configured will depend on if it is sandboxing a native or SFI (e.g. Wasm) based application.

**Sandboxing Native code**
When sandboxing native code, the code being sandboxed is entirely untrusted, and thus, it cannot be allowed to modify any of HFI's state, or exit the sandbox in unexpected ways, or perform any other operation that would allow it to violate the sandbox's policy. Thus, the sandbox options flags in `hfioptions_t` that are passed to `hfienter` to start the sandbox will: set the `lock_regions` flag to 1 (true), since sandboxed code cannot be trusted to modify regions; set the `redirect_system_calls` flag to 1, as again this code can't be trusted to perform system calls directly; set the `redirect_exit` flag to 1, ensuring all control flow out of the sandbox is redirect to the trusted runtime. The runtime will use an implicit data region to permit the sandboxed code to use of the sandbox memory; the runtime will then ensure the sandboxed code's stack, heap and inputs are part of this implicit region. An implicit code regions will be used to mark the code of the sandbox.

**Sandboxing using SFI runtimes**
When sandboxing code through SFI runtimes such as a Wasm runtime, sandboxing is handled as a mix of compiler/software-runtime checks as well as hardware checks from HFI. In the scenario, implementer has confidence in the correctness of the SFI's runtime and compiler, and thus their use of HFI is different from sandboxing code, giving it greater flexibility and performance.

For example, on `hfienter` it can set the `lock_regions` flag to 0 (false), allowing the compiler/runtime to modify regions with `hfisetregionsize` and `hfisetregionpermission` without having to exit the sandbox. This can allow regions to be used more flexibly, e.g. it can load and spilling registers, and never need to exit the sandbox. The `redirect_system_calls` flag can also be set to 0 (false), as the Wasm compiler disallows direct access to system call instructions, ensuring that any system calls made will come from the trusted runtime, this can eliminate the overhead of unecessary sandbox exits. What the redirect_exit flag will be set to depends on the SFI implementation, it may set this flag to false and opt to let sandbox exit's fall through to minimize overhead, since it can ensure that it knows that it can control whatever instruction follows an `hfiexit`, or it may opt to set it to true, and setup an exit_handler. For granting access to memory, the runtime will use implicit regions for code and data.

**Saving context**
A sandboxing runtime must protect its own execution context such as its stack and contents of CPU registers, before it switches to sandbox code. HFI leaves this mechanism entirely up to software---this flexibility is important for efficiency. For example, if our runtime is running untrusted native code---it will have to use springboards and trampolines cite:[nacl]---lightweight assembly routines that (1) clear registers and switch to a separate stack prior to executing the sandboxed code and (2) restore these registers after the sandboxed is executed. However, if it is running Wasm code, it could opt to use zero-cost transitions cite:[zero-cost] that rely on the compiler to ensure that the sandbox code cannot misuse the stack or scratch registers.

**Setting up an exit handler**
If our runtime needs an exit handler either to handle `hfiexit` or redirected system calls, it will need to setup an exit handler with `hfisetexithandler`. This exit handler is implemented as a normal function call in the runtime that takes no arguments. It will query the `hfiexitreason` CSR to find out why it was invoked.

**Entering the sandbox**
Having taken all these steps, our runtime is ready to start the sandbox. Once it calls `hfi_enter`, HFI mode is enabled, and the next instruction that runs will be inside a sandbox.

**The exit handler (`hfiexit` and system calls)**
When the exit handler is called after the sandbox exits, it will transfer control to the exit handler function in the runtime, which will check a control and status register (CSR) to identify the cause of the exit, and respond appropriately.

For example, for sandbox exits, it will need to save context unless the sandbox execution has completed. Similarly for system calls, it will need to save context, but then also execute whatever additional logic is need to check the parameters of the system call for safety and finally invoking the system call cite:[pku-pitfalls].

[[subsec_os_integration]]
==== OS (and VMM) integration

HFI is designed to require only minimal changes/support from the OS kernel. HFI requires support from OS kernels in two areas:

**Handling HFI faults**
A fault may occur in HFI mode for to two reasons: (1) normal processor traps such as illegal instructions. (2) HFI policy violations. In both cases, when the processor traps into the kernel, HFI enforcement is disabled so as not to disrupt kernel execution, and the trap is handled through all the normal OS signal mechanisms (This is automatic as HFI hardware checks are only applied to userspace code). When an instruction can trap due to some HFI policy violation, the normal trap mechanism for the current hart is employed. HFI introduces a new trap code, `hfi_fault` to support this.

When an HFI trap occurs, additional details about the cause are stored in the `hfifaultstatusreg`. A kernel trap handler can immediately read and store this state into the process struct for the current process, so it can be queried by a signal handler. The OS then invokes the standard signal handler registered by the application for memory access violations. The OS must invoke the signal handler with HFI disabled; if the signal handler returns control to the OS, the OS will re-enable HFI prior to resuming the faulting process.

**Process scheduling**
The kernel must save and restore HFI state (stored in internal registers) when switching between processes/VMs etc. This can be performed using the HFI manipulation instructions `hfiresetregions`, `hfisetregionpermission`, `hfisetregionsize`, `hfigetregionsize`, etc. To know whether HFI mode is currently enabled by the user space process, more privileged code can check the state of the `hfiusermodeenabled` status register.


[[sub_sec_instruction_encoding]]
=== Instruction Encoding

// With the exception of h-prefixed instructions (which we discuss separately), most HFI instructions such as transition instructions, region manipulation instructions have specific behavior and have little-to-no variation. Thus, to minimize opcode usage, these instructions can share a single opcode and simply be distinguished by the funct3 code. This optimization can be hidden from the end user by adding pseudo instructions to assemblers. Additionally some of these instructions can be implemented as pseudo instructions that read and writes to CSRs. To support backward compatible binaries, these instructions should be encoded using instructions that don't fault if not implemented.

HFI base extension introduces a set of functional instructions interacting with specific internal registers. Corresponding to the new internal registers, these instructions primarily fulfill three tasks: HFI mode transition, exit handler configuration, and region manipulation. All of the non-h-prefixed instructions are encoded in a R-type format under the same custom opcode `HFUNCTION` to achieve maximum flexibility (See <<fig_r_type,Figure 5>>). The funct 3 field differentiates the instructions based on the tasks, and the funct 7 field further distinguishes the specific instruction. The specific encoding is shown in <<tab_enc_non_h,Table 5>>. The behavior of these instructions has mostly been covered in <<sec_sbx_setup,todo>>, <<sec_exit_handler,todo>> and <<sec_regions,todo>>, and this section mainly details their encoding.

[[fig_r_type]]
.R-type instruction format.
image::Figures/r-type-cropped.svg[width=70%, align=center]


**HFI Mode Transition Instructions**
These include the `hfienter` and `hfiexit` instructions. `hfienter`'s 4-bit option vector comes from `rs1` and its `rd` field is invalid. The `hfiexit` instruction does not have any source or destination register, and thus these fields are all invalid in the instruction.

**Exit Handler Instructions**
These instructions include `hfisetexithandler` and `hfigetexithandler`. They only take one operand from `rs1` holding the address of the exit handler and configure the handler for sandbox exits and syscalls in the dedicated internal register `hfiexithandlerreg`.

**Region Manipulation Instructions**
These include the region-configure instruction `hfiselectregion`, the region size instructions `hfisetregionbase`, `hfigetregionbase`, `hfisetregionbound`, `hfigetregionbound`, and the region permissions `hfisetregionpermission`, `hfigetregionpermission`, `hfiresetregions`. All of these instructions directly interact with the corresponding internal registers, which are otherwise inaccessible. `hfiselectregion`, `hfisetregionbase`, `hfisetregionbound` and `hfisetregionpermission` all take a single operand from `rs1`, respectively the region number, the base address of the region and the mask for the region. The remaining "get" instructions set the `rd` register based on these internal registers.



[[tab_enc_non_h]]
.Encoding for R-type Non-h-prefixed Instructions
[cols="3,3,3,^3,3,3", options="header"]
|====
| funct3 | funct7 | Instruction | funct3 | funct7 | Instruction
| 000 | 0000000 | `hfienter` | 010 | 0000000 | `hfiselectregion`
| 000 | 0000001 | `hfiexit` | 010 | 0000001 | `hfisetregionbase`
| 000 | 0000010 | `hfientertarget` | 010 | 0000010 | `hfigetregionbase`
| 001 | 0000000 | `hfisetexithandler` | 010 | 0000011 | `hfisetregionpermission`
| 001 | 0000001 | `hfigetexithandler` | 010 | 0000100 | `hfigetregionpermission`
| 010 | 0000111 | `hfiresetregions` | | | 
|====

[[sub_sec_pending_considerations]]
=== Pending Design Considerations

Here, we include topics that we believe merit further discussion but which we have not fully resolved for inclusion in the specification.

==== Streamlining Control Transfers for Native Binaries

When sandboxing unmodified native binaries, we would ideally like control transfers into and out of the sandbox library to require minimal overhead and complexity. With a few small changes, we could make this simpler than what `hfienter` and `hfiexit` offer today.

At present, control transfers require redirecting control flow through small stubs (trampolines) that need to be mapped by the sandbox runtime into the sandboxed library address space, this adds complexity and overhead.

For example, consider a case where a host application has uses a library sandboxed with HFI; the applications want to invoke a function `foo()` in the library. To call `foo()`, it will need trampoline code---application code that performs a context switch by saving the current registers, switching the stack register to point to memory inside a region, enabling HFI and transferring control to `foo()`. This is mostly straightforward. However, once `foo` finishes executing (`foo` executes a return instruction), execution would attempt to return to the trampoline code---an operation that would fail as the trampoline code is not part of the sandbox code. Thus the host application, must perform an intermediate step---it must call `foo`, while modifying the return address on the stack to point to a stub within the sandbox, which invokes `hfiexit` and then returns to the trampoline. We could eliminate the need for this stub by dedicating a bit in the return address (e.g. it's least significant bit, as this should be unused as instructions are at least 16 bit aligned) on the stack that indicates that if HFI is enabled, this return should simply invoke `hfiexit`. Similar mechanism could also be applied to eliminating the need for trampolines for direct and indirect calls (i.e. callbacks) to host libraries.



==== HFI in M-mode or S-mode

We plan to add support for HFI in S-mode. Relatively small changes are necessary, however, we have not yet done a full analysis of how privileged instructions are handled. HFI support in m-mode may similarly be possible, but requires additional analysis for hardware implementation details.